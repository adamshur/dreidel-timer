<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Dreidel Timer</title>
<style>
  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --accent: #e2b04a;
    --accent2: #c8961e;
    --text: #eee;
    --text-dim: #8a8a9a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
  }

  h1 {
    font-size: 1.4rem;
    margin-top: max(env(safe-area-inset-top, 12px), 12px);
    color: var(--accent);
    letter-spacing: 0.05em;
  }

  #timer-display {
    font-size: 3.2rem;
    font-variant-numeric: tabular-nums;
    font-weight: 700;
    margin: 8px 0 4px;
    letter-spacing: 0.04em;
    min-height: 3.8rem;
  }

  #dreidel-canvas {
    flex-shrink: 0;
  }

  #finished-banner {
    display: none;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent);
    animation: pulse 0.6s ease-in-out infinite alternate;
    min-height: 2rem;
  }
  #finished-banner.show { display: block; }
  @keyframes pulse { from { opacity: 1; } to { opacity: 0.4; } }

  .spacer { flex: 1; min-height: 4px; max-height: 24px; }

  #controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    width: 100%;
    padding: 0 24px;
    max-width: 380px;
  }

  .preset-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .preset-btn {
    padding: 8px 16px;
    border-radius: 20px;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--accent);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    -webkit-tap-highlight-color: transparent;
  }
  .preset-btn:active, .preset-btn.active {
    background: var(--accent);
    color: var(--bg);
  }

  .custom-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .custom-row label { color: var(--text-dim); font-size: 0.85rem; }

  .time-input {
    width: 52px;
    padding: 6px 4px;
    border-radius: 10px;
    border: 2px solid var(--accent2);
    background: var(--surface);
    color: var(--text);
    font-size: 1.05rem;
    text-align: center;
    -webkit-appearance: none;
  }

  #start-btn {
    width: 100%;
    max-width: 260px;
    padding: 14px;
    border: none;
    border-radius: 28px;
    font-size: 1.15rem;
    font-weight: 700;
    cursor: pointer;
    background: var(--accent);
    color: var(--bg);
    letter-spacing: 0.04em;
    transition: opacity 0.2s;
    -webkit-tap-highlight-color: transparent;
  }
  #start-btn:active { opacity: 0.8; }
  #start-btn.cancel { background: #c0392b; color: #fff; }
</style>
</head>
<body>

<h1>Dreidel Timer</h1>
<div id="timer-display">0:00</div>
<canvas id="dreidel-canvas" width="440" height="580"></canvas>
<div id="finished-banner">Time's Up!</div>
<div class="spacer"></div>
<div id="controls">
  <div class="preset-row">
    <button class="preset-btn" data-sec="30">0:30</button>
    <button class="preset-btn active" data-sec="60">1:00</button>
    <button class="preset-btn" data-sec="120">2:00</button>
    <button class="preset-btn" data-sec="300">5:00</button>
    <button class="preset-btn" data-sec="600">10:00</button>
  </div>
  <div class="custom-row">
    <label>Custom:</label>
    <input class="time-input" id="input-min" type="number" min="0" max="99" value="1" inputmode="numeric" aria-label="Minutes">
    <label>m</label>
    <input class="time-input" id="input-sec" type="number" min="0" max="59" value="0" inputmode="numeric" aria-label="Seconds">
    <label>s</label>
  </div>
  <button id="start-btn">Start</button>
</div>
<div class="spacer"></div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const canvas  = $('dreidel-canvas');
  const ctx     = canvas.getContext('2d');
  const display = $('timer-display');
  const startBtn= $('start-btn');
  const banner  = $('finished-banner');
  const inputMin= $('input-min');
  const inputSec= $('input-sec');
  const presets = document.querySelectorAll('.preset-btn');

  // Hi-DPI
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = 440 * dpr;
  canvas.height = 580 * dpr;
  canvas.style.width  = '220px';
  canvas.style.height = '290px';
  ctx.scale(dpr, dpr);
  const CW = 220, CH = 290;

  // ---- 3D geometry ----
  // Dreidel centered at origin. Y-up is negative (canvas convention: +Y down).
  // Handle: box, Body: cube, Point: pyramid

  // Handle vertices (narrow box)
  const S = 50; // half-size of body cube
  const HS = 9; // half-size of handle
  const HT = -S - 50; // handle top y (above body)
  const HB = -S;      // handle bottom y
  const handleVerts = [
    [-HS, HT,  HS], [ HS, HT,  HS], [ HS, HB,  HS], [-HS, HB,  HS], // front
    [ HS, HT, -HS], [-HS, HT, -HS], [-HS, HB, -HS], [ HS, HB, -HS], // back
  ];
  const handleFaces = [
    { v: [0,1,2,3], base: '#d4a84b', dark: '#b8872a' }, // front
    { v: [4,5,6,7], base: '#b8872a', dark: '#9a6f1a' }, // back
    { v: [5,0,3,6], base: '#c49030', dark: '#a67818' }, // left
    { v: [1,4,7,2], base: '#c49030', dark: '#a67818' }, // right
    { v: [5,4,1,0], base: '#e2c06a', dark: '#c8961e' }, // top
  ];

  // Body cube vertices
  const bodyVerts = [
    [-S, -S,  S], [ S, -S,  S], [ S,  S,  S], [-S,  S,  S], // front
    [ S, -S, -S], [-S, -S, -S], [-S,  S, -S], [ S,  S, -S], // back
  ];
  const letters = ['נ', 'ג', 'ה', 'ש']; // front, right, back, left
  const bodyFaces = [
    { v: [0,1,2,3], base: '#e8c965', dark: '#c89520', letter: 'נ' }, // front
    { v: [1,4,7,2], base: '#dbb840', dark: '#b88518', letter: 'ג' }, // right
    { v: [4,5,6,7], base: '#c89520', dark: '#a67c15', letter: 'ה' }, // back
    { v: [5,0,3,6], base: '#dbb840', dark: '#b88518', letter: 'ש' }, // left
    { v: [5,4,1,0], base: '#edd87a', dark: '#c8961e' },              // top
    { v: [3,2,7,6], base: '#b88520', dark: '#9a6f1a' },              // bottom
  ];

  // Point pyramid vertices
  const PH = 90; // pyramid height
  const pointVerts = [
    [-S,  S,  S], [ S,  S,  S], [ S,  S, -S], [-S,  S, -S], // base (= body bottom)
    [ 0,  S + PH,  0], // apex
  ];
  const pointFaces = [
    { v: [0,1,4], base: '#d4a84b', dark: '#b89025' }, // front
    { v: [1,2,4], base: '#ba8c1e', dark: '#9a7515' }, // right
    { v: [2,3,4], base: '#b08018', dark: '#8a6510' }, // back
    { v: [3,0,4], base: '#c89520', dark: '#a67c15' }, // left
  ];

  // ---- 3D math ----
  function rotY(v, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [v[0]*c + v[2]*s, v[1], -v[0]*s + v[2]*c];
  }
  function rotZ(v, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [v[0]*c - v[1]*s, v[0]*s + v[1]*c, v[2]];
  }
  function rotX(v, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c];
  }

  // Perspective project: returns [sx, sy]
  const PERSP = 500;
  function project(v) {
    const scale = PERSP / (PERSP + v[2]);
    return [CW/2 + v[0] * scale, CH/2 + v[1] * scale];
  }

  // Face normal Z after projection (for back-face culling & lighting)
  function faceNormalZ(projected) {
    const a = projected[0], b = projected[1], c = projected[2];
    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0]);
  }

  // Average Z depth of transformed vertices
  function avgZ(verts, indices) {
    let sum = 0;
    for (const i of indices) sum += verts[i][2];
    return sum / indices.length;
  }

  // ---- Draw ----
  function drawDreidel(angleY, tiltZ, offsetX, offsetY) {
    ctx.clearRect(0, 0, CW, CH);

    // Transform all vertex sets
    function xform(v) {
      let p = rotY(v, angleY);
      if (tiltZ) p = rotZ(p, tiltZ);
      return [p[0] + offsetX, p[1] + offsetY, p[2]];
    }

    const hVerts = handleVerts.map(xform);
    const bVerts = bodyVerts.map(xform);
    const pVerts = pointVerts.map(xform);

    // Collect all faces with depth info
    const allFaces = [];
    function addFaces(faces, verts, group) {
      for (const f of faces) {
        const proj = f.v.map(i => project(verts[i]));
        const nz = faceNormalZ(proj);
        if (nz > 0) continue; // back-face cull (CW winding = front when nz < 0)
        allFaces.push({
          proj, f, depth: avgZ(verts, f.v), group
        });
      }
    }
    addFaces(handleFaces, hVerts, 'handle');
    addFaces(bodyFaces, bVerts, 'body');
    addFaces(pointFaces, pVerts, 'point');

    // Painter's algorithm: draw far to near
    allFaces.sort((a, b) => b.depth - a.depth);

    for (const { proj, f, group } of allFaces) {
      // Lighting: use normal z for shading
      const nz = faceNormalZ(proj);
      const brightness = Math.min(1, Math.max(0.3, -nz / 8000));

      ctx.beginPath();
      ctx.moveTo(proj[0][0], proj[0][1]);
      for (let i = 1; i < proj.length; i++) ctx.lineTo(proj[i][0], proj[i][1]);
      ctx.closePath();

      // Interpolate between dark and base color based on brightness
      ctx.fillStyle = brightness > 0.6 ? f.base : f.dark;
      ctx.fill();
      ctx.strokeStyle = 'rgba(100, 70, 20, 0.4)';
      ctx.lineWidth = 0.5;
      ctx.stroke();

      // Draw Hebrew letter on body faces
      if (f.letter && group === 'body') {
        const cx = proj.reduce((s, p) => s + p[0], 0) / proj.length;
        const cy = proj.reduce((s, p) => s + p[1], 0) / proj.length;
        // Estimate face size for font scaling
        const dx = proj[1][0] - proj[0][0];
        const dy = proj[1][1] - proj[0][1];
        const edgeLen = Math.sqrt(dx*dx + dy*dy);
        const fontSize = Math.max(12, edgeLen * 0.55);
        ctx.save();
        ctx.font = `bold ${fontSize}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(20, 10, 50, 0.85)';
        ctx.fillText(f.letter, cx, cy);
        ctx.restore();
      }
    }

    // Shadow
    const shadowY = CH/2 + (S + PH) * (PERSP / (PERSP + 0)) + 8 + offsetY;
    const shadowW = 50 + Math.abs(offsetX) * 0.5;
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(CW/2 + offsetX * 0.5, Math.min(shadowY, CH - 10), shadowW, 8, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fill();
    ctx.restore();
  }

  // ---- Animation state ----
  let spinAngle = 0;
  let spinSpeed = 0;       // rad/s
  let state = 'idle';      // idle | spinning | slowing | fallen
  let fallProgress = 0;    // 0..1
  let slowStart = 0;
  let animId = null;
  let lastTime = 0;

  const SPIN_SPEED = 8;    // rad/s when running
  const SLOW_DURATION = 1800; // ms to slow down
  const FALL_DURATION = 800;  // ms to fall over

  function animate(ts) {
    if (!lastTime) lastTime = ts;
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;

    let tiltZ = 0, offX = 0, offY = 0;

    if (state === 'spinning') {
      spinAngle += SPIN_SPEED * dt;
    } else if (state === 'slowing') {
      const elapsed = ts - slowStart;
      const t = Math.min(1, elapsed / SLOW_DURATION);
      // Ease-out deceleration
      const speed = SPIN_SPEED * (1 - t * t);
      spinAngle += speed * dt;
      if (t >= 1) {
        state = 'falling';
        slowStart = ts;
      }
    } else if (state === 'falling') {
      const elapsed = ts - slowStart;
      fallProgress = Math.min(1, elapsed / FALL_DURATION);
      // Ease-in-out
      const t = fallProgress < 0.5
        ? 2 * fallProgress * fallProgress
        : 1 - Math.pow(-2 * fallProgress + 2, 2) / 2;
      tiltZ = t * 1.45; // ~83 degrees
      offX = t * 25;
      offY = t * 30;
      if (fallProgress >= 1) {
        state = 'fallen';
        banner.classList.add('show');
        startBtn.textContent = 'Reset';
        startBtn.classList.remove('cancel');
        if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]);
      }
    } else if (state === 'fallen') {
      tiltZ = 1.45;
      offX = 25;
      offY = 30;
    }

    drawDreidel(spinAngle, tiltZ, offX, offY);
    animId = requestAnimationFrame(animate);
  }

  // Start render loop
  animId = requestAnimationFrame(animate);

  // ---- Timer logic ----
  let totalSeconds = 60;
  let remaining = 0;
  let interval = null;
  let running = false;

  function fmt(s) {
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return m + ':' + String(sec).padStart(2, '0');
  }

  function syncInputs() {
    inputMin.value = Math.floor(totalSeconds / 60);
    inputSec.value = totalSeconds % 60;
  }

  function readInputs() {
    const m = Math.max(0, parseInt(inputMin.value) || 0);
    const s = Math.max(0, Math.min(59, parseInt(inputSec.value) || 0));
    totalSeconds = m * 60 + s;
    if (totalSeconds < 1) totalSeconds = 1;
    presets.forEach(b => b.classList.remove('active'));
  }

  presets.forEach(btn => {
    btn.addEventListener('click', () => {
      if (running) return;
      presets.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      totalSeconds = parseInt(btn.dataset.sec);
      syncInputs();
      display.textContent = fmt(totalSeconds);
    });
  });

  inputMin.addEventListener('change', () => { if (!running) { readInputs(); display.textContent = fmt(totalSeconds); } });
  inputSec.addEventListener('change', () => { if (!running) { readInputs(); display.textContent = fmt(totalSeconds); } });

  function reset() {
    clearInterval(interval);
    interval = null;
    running = false;
    state = 'idle';
    spinAngle = 0;
    fallProgress = 0;
    banner.classList.remove('show');
    startBtn.textContent = 'Start';
    startBtn.classList.remove('cancel');
    display.textContent = fmt(totalSeconds);
  }

  function finish() {
    clearInterval(interval);
    interval = null;
    running = false;
    display.textContent = '0:00';
    state = 'slowing';
    slowStart = performance.now();
  }

  function start() {
    readInputs();
    remaining = totalSeconds;
    display.textContent = fmt(remaining);
    running = true;
    state = 'spinning';
    banner.classList.remove('show');
    fallProgress = 0;
    startBtn.textContent = 'Cancel';
    startBtn.classList.add('cancel');

    interval = setInterval(() => {
      remaining--;
      display.textContent = fmt(remaining);
      if (remaining <= 0) finish();
    }, 1000);
  }

  startBtn.addEventListener('click', () => {
    if (running) {
      reset();
    } else if (state === 'fallen') {
      reset();
    } else {
      start();
    }
  });

  display.textContent = fmt(totalSeconds);
  syncInputs();
})();
</script>
</body>
</html>
